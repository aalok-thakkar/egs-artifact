"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:389:2:390:65
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""Cannot construct from this node type"")"	call to expression	Cannot construct from this node type	file:///opt/src/src/ast.h:803:5:804:58
"static_assert(..., ""Cannot construct from this node type"")"	call to expression	Cannot construct from this node type	file:///opt/src/src/ast.h:811:5:812:58
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""not a function pointer"")"	! ...	not a function pointer	file:///usr/include/c++/9/bits/ptr_traits.h:153:7:153:77
"static_assert(..., ""pointer type defines element_type or is like SomePointer<T, Args>"")"	! ...	pointer type defines element_type or is like SomePointer<T, Args>	file:///usr/include/c++/9/bits/ptr_traits.h:114:7:115:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""value type is destructible"")"	value	value type is destructible	file:///usr/include/c++/9/bits/stl_construct.h:133:7:134:36
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""construction with an allocator must be possible if uses_allocator is true"")"	value	construction with an allocator must be possible if uses_allocator is true	file:///usr/include/c++/9/bits/uses_allocator.h:96:7:100:33
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:389:2:390:65
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""template argument must be an integral type"")"	value	template argument must be an integral type	file:///usr/include/c++/9/bits/uniform_int_dist.h:60:7:61:52
"static_assert(..., ""Incomplete or zero-sized types are not supported"")"	... > ...	Incomplete or zero-sized types are not supported	file:///usr/include/c++/9/atomic:194:7:195:58
"static_assert(..., ""std::atomic requires a trivially copyable type"")"	__is_trivially_copyable	std::atomic requires a trivially copyable type	file:///usr/include/c++/9/atomic:191:7:192:56
"static_assert(..., ""Wrong number of arguments for pointer-to-member"")"	... ? ... : ...	Wrong number of arguments for pointer-to-member	file:///usr/include/c++/9/functional:774:7:777:57
"static_assert(..., ""Wrong number of arguments for function"")"	... >= ...	Wrong number of arguments for function	file:///usr/include/c++/9/functional:765:7:766:61
"static_assert(..., ""Wrong number of arguments for function"")"	... == ...	Wrong number of arguments for function	file:///usr/include/c++/9/functional:758:7:759:61
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:482:7:483:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:479:7:480:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:478:7:478:69
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:453:7:454:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:450:7:451:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:449:7:449:69
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:445:7:445:70
"static_assert(..., ""division by 0"")"	... != ...	division by 0	file:///usr/include/c++/9/ratio:316:7:316:52
"static_assert(..., ""out of range"")"	... && ...	out of range	file:///usr/include/c++/9/ratio:264:7:265:22
"static_assert(..., ""denominator cannot be zero"")"	... != ...	denominator cannot be zero	file:///usr/include/c++/9/ratio:263:7:263:61
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:243:7:243:59
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:241:7:242:32
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:239:7:239:71
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:238:7:238:62
"static_assert(..., ""This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/"")"	... == ...	This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/	file:///usr/include/c++/9/ratio:212:7:215:38
"static_assert(..., ""Internal library error"")"	... != ...	Internal library error	file:///usr/include/c++/9/ratio:211:7:211:56
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:203:7:204:32
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:168:7:168:58
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:166:7:167:32
"static_assert(..., ""Internal library error"")"	! ...	Internal library error	file:///usr/include/c++/9/ratio:129:7:130:32
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:101:7:103:36
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:99:7:100:36
"static_assert(..., ""overflow in multiplication"")"	... < ...	overflow in multiplication	file:///usr/include/c++/9/ratio:97:7:98:36
"static_assert(..., ""overflow in multiplication"")"	... || ...	overflow in multiplication	file:///usr/include/c++/9/ratio:95:7:96:36
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""Only used for promise<void>"")"	value	Only used for promise<void>	file:///usr/include/c++/9/future:499:4:499:70
"static_assert(..., ""Invalid specialisation"")"	... || ...	Invalid specialisation	file:///usr/include/c++/9/future:467:11:469:40
"static_assert(..., ""topic_set_raw is too small"")"	... >= ...	topic_set_raw is too small	file:///opt/src/src/topic_monitor.h:72:5:73:48
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""template argument must be an integral type"")"	value	template argument must be an integral type	file:///usr/include/c++/9/bits/uniform_int_dist.h:60:7:61:52
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""rgb_color_t is too big"")"	... <= ...	rgb_color_t is too big	file:///opt/src/src/color.h:172:1:172:66
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:389:2:390:65
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""Incomplete or zero-sized types are not supported"")"	... > ...	Incomplete or zero-sized types are not supported	file:///usr/include/c++/9/atomic:194:7:195:58
"static_assert(..., ""std::atomic requires a trivially copyable type"")"	__is_trivially_copyable	std::atomic requires a trivially copyable type	file:///usr/include/c++/9/atomic:191:7:192:56
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::set must have a non-const, non-volatile value_type"")"	value	std::set must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_set.h:108:7:109:62
"static_assert(..., ""std::multiset must have a non-const, non-volatile value_type"")"	value	std::multiset must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_multiset.h:110:7:111:67
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""topic_set_raw is too small"")"	... >= ...	topic_set_raw is too small	file:///opt/src/src/topic_monitor.h:72:5:73:48
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""template argument must be an integral type"")"	value	template argument must be an integral type	file:///usr/include/c++/9/bits/uniform_int_dist.h:60:7:61:52
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5779:7:5780:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5508:7:5509:51
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:5273:7:5274:46
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5066:7:5067:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:4856:7:4857:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:4641:7:4642:51
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:4415:7:4416:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:4184:7:4185:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:3974:7:3975:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:3734:7:3735:46
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:3290:7:3291:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:3058:7:3059:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2850:7:2851:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2626:7:2627:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2398:7:2399:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2187:7:2188:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:1966:7:1967:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:1736:7:1737:51
"static_assert(..., ""template argument substituting __k out of bound"")"	... <= ...	template argument substituting __k out of bound	file:///usr/include/c++/9/bits/random.h:1315:7:1316:26
"static_assert(..., ""template argument substituting __w out of bounds"")"	... && ...	template argument substituting __w out of bounds	file:///usr/include/c++/9/bits/random.h:1098:7:1099:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:1096:7:1097:55
"static_assert(..., ""template argument substituting __r out of bounds"")"	... && ...	template argument substituting __r out of bounds	file:///usr/include/c++/9/bits/random.h:875:7:876:58
"static_assert(..., ""template argument substituting __w out of bounds"")"	... && ...	template argument substituting __w out of bounds	file:///usr/include/c++/9/bits/random.h:687:7:688:58
"static_assert(..., ""0 < s < r"")"	... && ...	0 < s < r	file:///usr/include/c++/9/bits/random.h:685:7:686:19
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:683:7:684:55
"static_assert(..., ""template argument substituting __f out of bound"")"	... <= ...	template argument substituting __f out of bound	file:///usr/include/c++/9/bits/random.h:487:7:488:57
"static_assert(..., ""template argument substituting __d out of bound"")"	... <= ...	template argument substituting __d out of bound	file:///usr/include/c++/9/bits/random.h:485:7:486:57
"static_assert(..., ""template argument substituting __c out of bound"")"	... <= ...	template argument substituting __c out of bound	file:///usr/include/c++/9/bits/random.h:483:7:484:57
"static_assert(..., ""template argument substituting __b out of bound"")"	... <= ...	template argument substituting __b out of bound	file:///usr/include/c++/9/bits/random.h:481:7:482:57
"static_assert(..., ""template argument substituting __a out of bound"")"	... <= ...	template argument substituting __a out of bound	file:///usr/include/c++/9/bits/random.h:479:7:480:57
"static_assert(..., ""template argument substituting __w out of bound"")"	... <= ...	template argument substituting __w out of bound	file:///usr/include/c++/9/bits/random.h:477:7:478:57
"static_assert(..., ""template argument substituting __l out of bound"")"	... <= ...	template argument substituting __l out of bound	file:///usr/include/c++/9/bits/random.h:475:7:476:26
"static_assert(..., ""template argument substituting __t out of bound"")"	... <= ...	template argument substituting __t out of bound	file:///usr/include/c++/9/bits/random.h:473:7:474:26
"static_assert(..., ""template argument substituting __s out of bound"")"	... <= ...	template argument substituting __s out of bound	file:///usr/include/c++/9/bits/random.h:471:7:472:26
"static_assert(..., ""template argument substituting __u out of bound"")"	... <= ...	template argument substituting __u out of bound	file:///usr/include/c++/9/bits/random.h:469:7:470:26
"static_assert(..., ""template argument substituting __r out of bound"")"	... <= ...	template argument substituting __r out of bound	file:///usr/include/c++/9/bits/random.h:467:7:468:26
"static_assert(..., ""template argument substituting __m out of bounds"")"	... && ...	template argument substituting __m out of bounds	file:///usr/include/c++/9/bits/random.h:465:7:466:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:463:7:464:55
"static_assert(..., ""template argument substituting __m out of bounds"")"	... || ...	template argument substituting __m out of bounds	file:///usr/include/c++/9/bits/random.h:248:7:249:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:246:7:247:55
"static_assert(..., ""template argument must be a floating point type"")"	value	template argument must be a floating point type	file:///usr/include/c++/9/bits/random.h:156:2:157:59
"static_assert(..., ""sorry, would be too much trouble for a slow result"")"	... < ...	sorry, would be too much trouble for a slow result	file:///usr/include/c++/9/bits/random.h:84:2:85:62
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::set must have a non-const, non-volatile value_type"")"	value	std::set must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_set.h:108:7:109:62
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:389:2:390:65
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:389:2:390:65
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""pointer type defines element_type or is like SomePointer<T, Args>"")"	! ...	pointer type defines element_type or is like SomePointer<T, Args>	file:///usr/include/c++/9/bits/ptr_traits.h:114:7:115:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""Incomplete or zero-sized types are not supported"")"	... > ...	Incomplete or zero-sized types are not supported	file:///usr/include/c++/9/atomic:194:7:195:58
"static_assert(..., ""std::atomic requires a trivially copyable type"")"	__is_trivially_copyable	std::atomic requires a trivially copyable type	file:///usr/include/c++/9/atomic:191:7:192:56
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::set must have a non-const, non-volatile value_type"")"	value	std::set must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_set.h:108:7:109:62
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""incomplete type"")"	... > ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1128:4:1128:55
"static_assert(..., ""incomplete type"")"	! ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1127:4:1127:60
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::set must have a non-const, non-volatile value_type"")"	value	std::set must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_set.h:108:7:109:62
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:482:7:483:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:479:7:480:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:478:7:478:69
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:453:7:454:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:450:7:451:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:449:7:449:69
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:445:7:445:70
"static_assert(..., ""division by 0"")"	... != ...	division by 0	file:///usr/include/c++/9/ratio:316:7:316:52
"static_assert(..., ""out of range"")"	... && ...	out of range	file:///usr/include/c++/9/ratio:264:7:265:22
"static_assert(..., ""denominator cannot be zero"")"	... != ...	denominator cannot be zero	file:///usr/include/c++/9/ratio:263:7:263:61
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:243:7:243:59
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:241:7:242:32
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:239:7:239:71
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:238:7:238:62
"static_assert(..., ""This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/"")"	... == ...	This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/	file:///usr/include/c++/9/ratio:212:7:215:38
"static_assert(..., ""Internal library error"")"	... != ...	Internal library error	file:///usr/include/c++/9/ratio:211:7:211:56
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:203:7:204:32
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:168:7:168:58
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:166:7:167:32
"static_assert(..., ""Internal library error"")"	! ...	Internal library error	file:///usr/include/c++/9/ratio:129:7:130:32
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:101:7:103:36
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:99:7:100:36
"static_assert(..., ""overflow in multiplication"")"	... < ...	overflow in multiplication	file:///usr/include/c++/9/ratio:97:7:98:36
"static_assert(..., ""overflow in multiplication"")"	... || ...	overflow in multiplication	file:///usr/include/c++/9/ratio:95:7:96:36
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:113:2:114:51
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""value type is destructible"")"	value	value type is destructible	file:///usr/include/c++/9/bits/stl_construct.h:133:7:134:36
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5779:7:5780:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5508:7:5509:51
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:5273:7:5274:46
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:5066:7:5067:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:4856:7:4857:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:4641:7:4642:51
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:4415:7:4416:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:4184:7:4185:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:3974:7:3975:46
"static_assert(..., ""result_type must be an integral type"")"	value	result_type must be an integral type	file:///usr/include/c++/9/bits/random.h:3734:7:3735:46
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:3290:7:3291:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:3058:7:3059:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2850:7:2851:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2626:7:2627:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2398:7:2399:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:2187:7:2188:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:1966:7:1967:51
"static_assert(..., ""result_type must be a floating point type"")"	value	result_type must be a floating point type	file:///usr/include/c++/9/bits/random.h:1736:7:1737:51
"static_assert(..., ""template argument substituting __k out of bound"")"	... <= ...	template argument substituting __k out of bound	file:///usr/include/c++/9/bits/random.h:1315:7:1316:26
"static_assert(..., ""template argument substituting __w out of bounds"")"	... && ...	template argument substituting __w out of bounds	file:///usr/include/c++/9/bits/random.h:1098:7:1099:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:1096:7:1097:55
"static_assert(..., ""template argument substituting __r out of bounds"")"	... && ...	template argument substituting __r out of bounds	file:///usr/include/c++/9/bits/random.h:875:7:876:58
"static_assert(..., ""template argument substituting __w out of bounds"")"	... && ...	template argument substituting __w out of bounds	file:///usr/include/c++/9/bits/random.h:687:7:688:58
"static_assert(..., ""0 < s < r"")"	... && ...	0 < s < r	file:///usr/include/c++/9/bits/random.h:685:7:686:19
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:683:7:684:55
"static_assert(..., ""template argument substituting __f out of bound"")"	... <= ...	template argument substituting __f out of bound	file:///usr/include/c++/9/bits/random.h:487:7:488:57
"static_assert(..., ""template argument substituting __d out of bound"")"	... <= ...	template argument substituting __d out of bound	file:///usr/include/c++/9/bits/random.h:485:7:486:57
"static_assert(..., ""template argument substituting __c out of bound"")"	... <= ...	template argument substituting __c out of bound	file:///usr/include/c++/9/bits/random.h:483:7:484:57
"static_assert(..., ""template argument substituting __b out of bound"")"	... <= ...	template argument substituting __b out of bound	file:///usr/include/c++/9/bits/random.h:481:7:482:57
"static_assert(..., ""template argument substituting __a out of bound"")"	... <= ...	template argument substituting __a out of bound	file:///usr/include/c++/9/bits/random.h:479:7:480:57
"static_assert(..., ""template argument substituting __w out of bound"")"	... <= ...	template argument substituting __w out of bound	file:///usr/include/c++/9/bits/random.h:477:7:478:57
"static_assert(..., ""template argument substituting __l out of bound"")"	... <= ...	template argument substituting __l out of bound	file:///usr/include/c++/9/bits/random.h:475:7:476:26
"static_assert(..., ""template argument substituting __t out of bound"")"	... <= ...	template argument substituting __t out of bound	file:///usr/include/c++/9/bits/random.h:473:7:474:26
"static_assert(..., ""template argument substituting __s out of bound"")"	... <= ...	template argument substituting __s out of bound	file:///usr/include/c++/9/bits/random.h:471:7:472:26
"static_assert(..., ""template argument substituting __u out of bound"")"	... <= ...	template argument substituting __u out of bound	file:///usr/include/c++/9/bits/random.h:469:7:470:26
"static_assert(..., ""template argument substituting __r out of bound"")"	... <= ...	template argument substituting __r out of bound	file:///usr/include/c++/9/bits/random.h:467:7:468:26
"static_assert(..., ""template argument substituting __m out of bounds"")"	... && ...	template argument substituting __m out of bounds	file:///usr/include/c++/9/bits/random.h:465:7:466:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:463:7:464:55
"static_assert(..., ""template argument substituting __m out of bounds"")"	... || ...	template argument substituting __m out of bounds	file:///usr/include/c++/9/bits/random.h:248:7:249:58
"static_assert(..., ""result_type must be an unsigned integral type"")"	value	result_type must be an unsigned integral type	file:///usr/include/c++/9/bits/random.h:246:7:247:55
"static_assert(..., ""template argument must be a floating point type"")"	value	template argument must be a floating point type	file:///usr/include/c++/9/bits/random.h:156:2:157:59
"static_assert(..., ""sorry, would be too much trouble for a slow result"")"	... < ...	sorry, would be too much trouble for a slow result	file:///usr/include/c++/9/bits/random.h:84:2:85:62
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""value type is destructible"")"	value	value type is destructible	file:///usr/include/c++/9/bits/stl_construct.h:133:7:134:36
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""input_function_metadata size mismatch with input_common. Did you forget to update input_function_metadata?"")"	... == ...	input_function_metadata size mismatch with input_common. Did you forget to update input_function_metadata?	file:///opt/src/src/input.cpp:157:1:160:42
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""value type is destructible"")"	value	value type is destructible	file:///usr/include/c++/9/bits/stl_construct.h:133:7:134:36
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""Only used for promise<void>"")"	value	Only used for promise<void>	file:///usr/include/c++/9/future:499:4:499:70
"static_assert(..., ""Invalid specialisation"")"	... || ...	Invalid specialisation	file:///usr/include/c++/9/future:467:11:469:40
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""value type is destructible"")"	value	value type is destructible	file:///usr/include/c++/9/bits/stl_construct.h:133:7:134:36
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:482:7:483:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:479:7:480:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:478:7:478:69
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:453:7:454:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:450:7:451:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:449:7:449:69
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:445:7:445:70
"static_assert(..., ""division by 0"")"	... != ...	division by 0	file:///usr/include/c++/9/ratio:316:7:316:52
"static_assert(..., ""out of range"")"	... && ...	out of range	file:///usr/include/c++/9/ratio:264:7:265:22
"static_assert(..., ""denominator cannot be zero"")"	... != ...	denominator cannot be zero	file:///usr/include/c++/9/ratio:263:7:263:61
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:243:7:243:59
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:241:7:242:32
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:239:7:239:71
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:238:7:238:62
"static_assert(..., ""This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/"")"	... == ...	This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/	file:///usr/include/c++/9/ratio:212:7:215:38
"static_assert(..., ""Internal library error"")"	... != ...	Internal library error	file:///usr/include/c++/9/ratio:211:7:211:56
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:203:7:204:32
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:168:7:168:58
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:166:7:167:32
"static_assert(..., ""Internal library error"")"	! ...	Internal library error	file:///usr/include/c++/9/ratio:129:7:130:32
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:101:7:103:36
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:99:7:100:36
"static_assert(..., ""overflow in multiplication"")"	... < ...	overflow in multiplication	file:///usr/include/c++/9/ratio:97:7:98:36
"static_assert(..., ""overflow in multiplication"")"	... || ...	overflow in multiplication	file:///usr/include/c++/9/ratio:95:7:96:36
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""Invalid block process"")"	... || ...	Invalid block process	file:///opt/src/src/parse_execution.cpp:1007:5:1010:43
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""incomplete type"")"	... > ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1128:4:1128:55
"static_assert(..., ""incomplete type"")"	! ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1127:4:1127:60
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""Unexpected node type"")"	... || ...	Unexpected node type	file:///opt/src/src/parser.cpp:670:5:672:32
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""Incomplete or zero-sized types are not supported"")"	... > ...	Incomplete or zero-sized types are not supported	file:///usr/include/c++/9/atomic:194:7:195:58
"static_assert(..., ""std::atomic requires a trivially copyable type"")"	__is_trivially_copyable	std::atomic requires a trivially copyable type	file:///usr/include/c++/9/atomic:191:7:192:56
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""incomplete type"")"	... > ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1128:4:1128:55
"static_assert(..., ""incomplete type"")"	! ...	incomplete type	file:///usr/include/c++/9/bits/shared_ptr_base.h:1127:4:1127:60
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""topic_set_raw is too small"")"	... >= ...	topic_set_raw is too small	file:///opt/src/src/topic_monitor.h:72:5:73:48
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""Incomplete or zero-sized types are not supported"")"	... > ...	Incomplete or zero-sized types are not supported	file:///usr/include/c++/9/atomic:194:7:195:58
"static_assert(..., ""std::atomic requires a trivially copyable type"")"	__is_trivially_copyable	std::atomic requires a trivially copyable type	file:///usr/include/c++/9/atomic:191:7:192:56
"static_assert(..., ""relocation is only possible for values of the same type"")"	value	relocation is only possible for values of the same type	file:///usr/include/c++/9/bits/stl_uninitialized.h:928:7:929:62
"static_assert(..., ""can't delete pointer to incomplete type"")"	... > ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:79:2:80:51
"static_assert(..., ""can't delete pointer to incomplete type"")"	! ...	can't delete pointer to incomplete type	file:///usr/include/c++/9/bits/unique_ptr.h:77:2:78:51
"static_assert(..., ""unique_ptr's deleter must be invocable with a pointer"")"	value	unique_ptr's deleter must be invocable with a pointer	file:///usr/include/c++/9/bits/unique_ptr.h:280:2:281:65
"static_assert(..., ""unique_ptr's deleter type must be a function object type or an lvalue reference type"")"	! ...	unique_ptr's deleter type must be a function object type or an lvalue reference type	file:///usr/include/c++/9/bits/unique_ptr.h:142:7:144:40
"static_assert(..., ""comparison object must be invocable with two arguments of key type"")"	{...}	comparison object must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/stl_tree.h:772:2:774:42
"static_assert(..., ""std::set must have a non-const, non-volatile value_type"")"	value	std::set must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_set.h:108:7:109:62
"static_assert(..., ""std::deque must have a non-const, non-volatile value_type"")"	value	std::deque must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_deque.h:858:7:859:64
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""std::list must have a non-const, non-volatile value_type"")"	value	std::list must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_list.h:564:7:565:63
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:482:7:483:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:479:7:480:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:478:7:478:69
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:453:7:454:67
"static_assert(..., ""overflow in addition"")"	... && ...	overflow in addition	file:///usr/include/c++/9/ratio:450:7:451:72
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:449:7:449:69
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:445:7:445:70
"static_assert(..., ""division by 0"")"	... != ...	division by 0	file:///usr/include/c++/9/ratio:316:7:316:52
"static_assert(..., ""out of range"")"	... && ...	out of range	file:///usr/include/c++/9/ratio:264:7:265:22
"static_assert(..., ""denominator cannot be zero"")"	... != ...	denominator cannot be zero	file:///usr/include/c++/9/ratio:263:7:263:61
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:243:7:243:59
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:241:7:242:32
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:239:7:239:71
"static_assert(..., ""Internal library error"")"	... == ...	Internal library error	file:///usr/include/c++/9/ratio:238:7:238:62
"static_assert(..., ""This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/"")"	... == ...	This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzilla/	file:///usr/include/c++/9/ratio:212:7:215:38
"static_assert(..., ""Internal library error"")"	... != ...	Internal library error	file:///usr/include/c++/9/ratio:211:7:211:56
"static_assert(..., ""Internal library error"")"	... && ...	Internal library error	file:///usr/include/c++/9/ratio:203:7:204:32
"static_assert(..., ""Internal library error"")"	... < ...	Internal library error	file:///usr/include/c++/9/ratio:168:7:168:58
"static_assert(..., ""Internal library error"")"	... >= ...	Internal library error	file:///usr/include/c++/9/ratio:166:7:167:32
"static_assert(..., ""Internal library error"")"	! ...	Internal library error	file:///usr/include/c++/9/ratio:129:7:130:32
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:101:7:103:36
"static_assert(..., ""overflow in multiplication"")"	... <= ...	overflow in multiplication	file:///usr/include/c++/9/ratio:99:7:100:36
"static_assert(..., ""overflow in multiplication"")"	... < ...	overflow in multiplication	file:///usr/include/c++/9/ratio:97:7:98:36
"static_assert(..., ""overflow in multiplication"")"	... || ...	overflow in multiplication	file:///usr/include/c++/9/ratio:95:7:96:36
"static_assert(..., ""a clock's minimum duration cannot be less than its epoch"")"	call to operator<	a clock's minimum duration cannot be less than its epoch	file:///usr/include/c++/9/chrono:835:7:837:66
"static_assert(..., ""period must be positive"")"	... > ...	period must be positive	file:///usr/include/c++/9/chrono:319:2:319:60
"static_assert(..., ""period must be a specialization of ratio"")"	value	period must be a specialization of ratio	file:///usr/include/c++/9/chrono:317:2:318:52
"static_assert(..., ""rep cannot be a duration"")"	! ...	rep cannot be a duration	file:///usr/include/c++/9/chrono:316:2:316:72
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""index is out of bounds"")"	... < ...	index is out of bounds	file:///usr/include/c++/9/array:365:7:365:58
"static_assert(..., ""topic_set_raw is too small"")"	... >= ...	topic_set_raw is too small	file:///opt/src/src/topic_monitor.h:72:5:73:48
"static_assert(..., ""Synthetic exit status not reported as exited"")"	... == ...	Synthetic exit status not reported as exited	file:///opt/src/src/proc.h:76:9:76:91
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""At least one type is required"")"	... != ...	At least one type is required	file:///usr/include/c++/9/type_traits:1973:7:1973:77
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:584:4:584:72
"static_assert(..., ""type is not assignable"")"	value	type is not assignable	file:///usr/include/c++/9/bits/stl_algobase.h:382:4:382:72
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1290:2:1291:69
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""Functor used to map hash code to bucket index must be default constructible"")"	value	Functor used to map hash code to bucket index must be default constructible	file:///usr/include/c++/9/bits/hashtable.h:286:7:288:40
"static_assert(..., ""Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept"")"	Unknown literal	Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept	file:///usr/include/c++/9/bits/hashtable.h:275:7:279:66
"static_assert(..., ""unordered container must have a non-const, non-volatile value_type"")"	value	unordered container must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/hashtable.h:189:7:190:73
"static_assert(..., ""tuple index is in range"")"	... < ...	tuple index is in range	file:///usr/include/c++/9/tuple:1303:7:1304:30
"static_assert(..., ""key equality predicate must be invocable with two arguments of key type"")"	{...}	key equality predicate must be invocable with two arguments of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1831:7:1833:15
"static_assert(..., ""hash function must be invocable with an argument of key type"")"	{...}	hash function must be invocable with an argument of key type	file:///usr/include/c++/9/bits/hashtable_policy.h:1382:2:1383:69
"static_assert(..., ""Type must be empty"")"	value	Type must be empty	file:///usr/include/c++/9/bits/hashtable_policy.h:1530:7:1530:71
"static_assert(..., ""std::vector must have a non-const, non-volatile value_type"")"	value	std::vector must have a non-const, non-volatile value_type	file:///usr/include/c++/9/bits/stl_vector.h:398:7:399:65
